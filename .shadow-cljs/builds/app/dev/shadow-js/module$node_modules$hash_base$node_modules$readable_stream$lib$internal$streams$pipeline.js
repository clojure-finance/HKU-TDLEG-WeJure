["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"~:js","shadow$provide.module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$pipeline=function(global,require,module,exports){function once(callback){var called=!1;return function(){called||(called=!0,callback.apply(void 0,arguments))}}function noop(err){if(err)throw err;}function destroyer(stream,reading,writing,callback){callback=once(callback);var closed=!1;stream.on(\"close\",function(){closed=!0});void 0===eos&&(eos=require(\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$end_of_stream\"));\neos(stream,{readable:reading,writable:writing},function(err){if(err)return callback(err);closed=!0;callback()});var destroyed=!1;return function(err){if(!closed&&!destroyed){destroyed=!0;if(stream.setHeader&&\"function\"===typeof stream.abort)return stream.abort();if(\"function\"===typeof stream.destroy)return stream.destroy();callback(err||new ERR_STREAM_DESTROYED(\"pipe\"))}}}function call(fn){fn()}function pipe(from,to){return from.pipe(to)}var eos;global=require(\"module$node_modules$hash_base$node_modules$readable_stream$errors\").codes;\nvar ERR_MISSING_ARGS=global.ERR_MISSING_ARGS,ERR_STREAM_DESTROYED=global.ERR_STREAM_DESTROYED;module.exports=function(){for(var _len=arguments.length,streams=Array(_len),_key=0;_key<_len;_key++)streams[_key]=arguments[_key];var callback=streams.length?\"function\"!==typeof streams[streams.length-1]?noop:streams.pop():noop;Array.isArray(streams[0])&&(streams=streams[0]);if(2>streams.length)throw new ERR_MISSING_ARGS(\"streams\");var error,destroys=streams.map(function(stream,i){var reading=i<streams.length-\n1;return destroyer(stream,reading,0<i,function(err){error||(error=err);err&&destroys.forEach(call);reading||(destroys.forEach(call),callback(error))})});return streams.reduce(pipe)}}","~:source","shadow$provide[\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$pipeline\"] = function(global,require,module,exports) {\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$hash_base$node_modules$readable_stream$errors","~$shadow.js","~$module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$end_of_stream"]],"~:properties",["^5",["readable","writable"]],"~:compiled-at",1644840879884,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$pipeline.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$hash_base$node_modules$readable_stream$lib$internal$streams$pipeline\\\"] = function(global,require,module,exports) {\\n// Ported from https://github.com/mafintosh/pump with\\n// permission from the author, Mathias Buus (@mafintosh).\\n'use strict';\\n\\nvar eos;\\n\\nfunction once(callback) {\\n  var called = false;\\n  return function () {\\n    if (called) return;\\n    called = true;\\n    callback.apply(void 0, arguments);\\n  };\\n}\\n\\nvar _require$codes = require('../../../errors').codes,\\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\\n\\nfunction noop(err) {\\n  // Rethrow the error if it exists to avoid swallowing it\\n  if (err) throw err;\\n}\\n\\nfunction isRequest(stream) {\\n  return stream.setHeader && typeof stream.abort === 'function';\\n}\\n\\nfunction destroyer(stream, reading, writing, callback) {\\n  callback = once(callback);\\n  var closed = false;\\n  stream.on('close', function () {\\n    closed = true;\\n  });\\n  if (eos === undefined) eos = require('./end-of-stream');\\n  eos(stream, {\\n    readable: reading,\\n    writable: writing\\n  }, function (err) {\\n    if (err) return callback(err);\\n    closed = true;\\n    callback();\\n  });\\n  var destroyed = false;\\n  return function (err) {\\n    if (closed) return;\\n    if (destroyed) return;\\n    destroyed = true; // request.destroy just do .end - .abort is what we want\\n\\n    if (isRequest(stream)) return stream.abort();\\n    if (typeof stream.destroy === 'function') return stream.destroy();\\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\\n  };\\n}\\n\\nfunction call(fn) {\\n  fn();\\n}\\n\\nfunction pipe(from, to) {\\n  return from.pipe(to);\\n}\\n\\nfunction popCallback(streams) {\\n  if (!streams.length) return noop;\\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\\n  return streams.pop();\\n}\\n\\nfunction pipeline() {\\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\\n    streams[_key] = arguments[_key];\\n  }\\n\\n  var callback = popCallback(streams);\\n  if (Array.isArray(streams[0])) streams = streams[0];\\n\\n  if (streams.length < 2) {\\n    throw new ERR_MISSING_ARGS('streams');\\n  }\\n\\n  var error;\\n  var destroys = streams.map(function (stream, i) {\\n    var reading = i < streams.length - 1;\\n    var writing = i > 0;\\n    return destroyer(stream, reading, writing, function (err) {\\n      if (!error) error = err;\\n      if (err) destroys.forEach(call);\\n      if (reading) return;\\n      destroys.forEach(call);\\n      callback(error);\\n    });\\n  });\\n  return streams.reduce(pipe);\\n}\\n\\nmodule.exports = pipeline;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"once\",\"callback\",\"called\",\"apply\",\"arguments\",\"noop\",\"err\",\"destroyer\",\"stream\",\"reading\",\"writing\",\"closed\",\"on\",\"undefined\",\"eos\",\"readable\",\"writable\",\"destroyed\",\"setHeader\",\"abort\",\"destroy\",\"ERR_STREAM_DESTROYED\",\"call\",\"fn\",\"pipe\",\"from\",\"to\",\"_require$codes\",\"codes\",\"ERR_MISSING_ARGS\",\"pipeline\",\"_len\",\"length\",\"streams\",\"Array\",\"_key\",\"pop\",\"isArray\",\"error\",\"destroys\",\"map\",\"i\",\"forEach\",\"reduce\"]\n}\n"]