["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/public-encrypt/publicEncrypt.js"],"~:js","shadow$provide.module$node_modules$public_encrypt$publicEncrypt=function(global,require,module,exports){var parseKeys=require(\"module$node_modules$parse_asn1$index\"),randomBytes=require(\"module$node_modules$randombytes$browser\"),createHash=require(\"module$node_modules$create_hash$browser\"),mgf=require(\"module$node_modules$public_encrypt$mgf\"),xor=require(\"module$node_modules$public_encrypt$xor\"),BN=require(\"module$node_modules$bn_DOT_js$lib$bn\"),withPublic=require(\"module$node_modules$public_encrypt$withPublic\"),\ncrt=require(\"module$node_modules$browserify_rsa$index\"),Buffer=require(\"module$node_modules$safe_buffer$index\").Buffer;module.exports=function(publicKey,msg,reverse){var padding=publicKey.padding?publicKey.padding:reverse?1:4;publicKey=parseKeys(publicKey);if(4===padding){padding=publicKey.modulus.byteLength();var mLen=msg.length,iHash=createHash(\"sha1\").update(Buffer.alloc(0)).digest(),hLen=iHash.length,hLen2=2*hLen;if(mLen>padding-hLen2-2)throw Error(\"message too long\");hLen2=Buffer.alloc(padding-\nmLen-hLen2-2);var dblen=padding-hLen-1;mLen=randomBytes(hLen);msg=xor(Buffer.concat([iHash,hLen2,Buffer.alloc(1,1),msg],dblen),mgf(mLen,dblen));hLen=xor(mLen,mgf(msg,hLen));msg=new BN(Buffer.concat([Buffer.alloc(1),hLen,msg],padding))}else if(1===padding){hLen=msg.length;padding=publicKey.modulus.byteLength();if(hLen>padding-11)throw Error(\"message too long\");if(reverse)hLen=Buffer.alloc(padding-hLen-3,255);else{hLen=padding-hLen-3;iHash=Buffer.allocUnsafe(hLen);mLen=0;hLen2=randomBytes(2*hLen);dblen=\n0;for(var num;mLen<hLen;)dblen===hLen2.length&&(hLen2=randomBytes(2*hLen),dblen=0),(num=hLen2[dblen++])&&(iHash[mLen++]=num);hLen=iHash}msg=new BN(Buffer.concat([Buffer.from([0,reverse?1:2]),hLen,Buffer.alloc(1),msg],padding))}else if(3===padding){if(msg=new BN(msg),0<=msg.cmp(publicKey.modulus))throw Error(\"data too long for modulus\");}else throw Error(\"unknown padding\");return reverse?crt(msg,publicKey):withPublic(msg,publicKey)}}","~:source","shadow$provide[\"module$node_modules$public_encrypt$publicEncrypt\"] = function(global,require,module,exports) {\nvar parseKeys = require('parse-asn1')\nvar randomBytes = require('randombytes')\nvar createHash = require('create-hash')\nvar mgf = require('./mgf')\nvar xor = require('./xor')\nvar BN = require('bn.js')\nvar withPublic = require('./withPublic')\nvar crt = require('browserify-rsa')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function publicEncrypt (publicKey, msg, reverse) {\n  var padding\n  if (publicKey.padding) {\n    padding = publicKey.padding\n  } else if (reverse) {\n    padding = 1\n  } else {\n    padding = 4\n  }\n  var key = parseKeys(publicKey)\n  var paddedMsg\n  if (padding === 4) {\n    paddedMsg = oaep(key, msg)\n  } else if (padding === 1) {\n    paddedMsg = pkcs1(key, msg, reverse)\n  } else if (padding === 3) {\n    paddedMsg = new BN(msg)\n    if (paddedMsg.cmp(key.modulus) >= 0) {\n      throw new Error('data too long for modulus')\n    }\n  } else {\n    throw new Error('unknown padding')\n  }\n  if (reverse) {\n    return crt(paddedMsg, key)\n  } else {\n    return withPublic(paddedMsg, key)\n  }\n}\n\nfunction oaep (key, msg) {\n  var k = key.modulus.byteLength()\n  var mLen = msg.length\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\n  var hLen = iHash.length\n  var hLen2 = 2 * hLen\n  if (mLen > k - hLen2 - 2) {\n    throw new Error('message too long')\n  }\n  var ps = Buffer.alloc(k - mLen - hLen2 - 2)\n  var dblen = k - hLen - 1\n  var seed = randomBytes(hLen)\n  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen))\n  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))\n}\nfunction pkcs1 (key, msg, reverse) {\n  var mLen = msg.length\n  var k = key.modulus.byteLength()\n  if (mLen > k - 11) {\n    throw new Error('message too long')\n  }\n  var ps\n  if (reverse) {\n    ps = Buffer.alloc(k - mLen - 3, 0xff)\n  } else {\n    ps = nonZero(k - mLen - 3)\n  }\n  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))\n}\nfunction nonZero (len) {\n  var out = Buffer.allocUnsafe(len)\n  var i = 0\n  var cache = randomBytes(len * 2)\n  var cur = 0\n  var num\n  while (i < len) {\n    if (cur === cache.length) {\n      cache = randomBytes(len * 2)\n      cur = 0\n    }\n    num = cache[cur++]\n    if (num) {\n      out[i++] = num\n    }\n  }\n  return out\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$public_encrypt$withPublic","~$module$node_modules$public_encrypt$xor","~$module$node_modules$create_hash$browser","~$shadow.js","~$module$node_modules$safe_buffer$index","~$module$node_modules$parse_asn1$index","~$module$node_modules$public_encrypt$mgf","~$module$node_modules$randombytes$browser","~$module$node_modules$bn_DOT_js$lib$bn","~$module$node_modules$browserify_rsa$index"]],"~:properties",["^5",[]],"~:compiled-at",1644840880008,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$public_encrypt$publicEncrypt.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/public-encrypt/publicEncrypt.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$public_encrypt$publicEncrypt\\\"] = function(global,require,module,exports) {\\nvar parseKeys = require('parse-asn1')\\nvar randomBytes = require('randombytes')\\nvar createHash = require('create-hash')\\nvar mgf = require('./mgf')\\nvar xor = require('./xor')\\nvar BN = require('bn.js')\\nvar withPublic = require('./withPublic')\\nvar crt = require('browserify-rsa')\\nvar Buffer = require('safe-buffer').Buffer\\n\\nmodule.exports = function publicEncrypt (publicKey, msg, reverse) {\\n  var padding\\n  if (publicKey.padding) {\\n    padding = publicKey.padding\\n  } else if (reverse) {\\n    padding = 1\\n  } else {\\n    padding = 4\\n  }\\n  var key = parseKeys(publicKey)\\n  var paddedMsg\\n  if (padding === 4) {\\n    paddedMsg = oaep(key, msg)\\n  } else if (padding === 1) {\\n    paddedMsg = pkcs1(key, msg, reverse)\\n  } else if (padding === 3) {\\n    paddedMsg = new BN(msg)\\n    if (paddedMsg.cmp(key.modulus) >= 0) {\\n      throw new Error('data too long for modulus')\\n    }\\n  } else {\\n    throw new Error('unknown padding')\\n  }\\n  if (reverse) {\\n    return crt(paddedMsg, key)\\n  } else {\\n    return withPublic(paddedMsg, key)\\n  }\\n}\\n\\nfunction oaep (key, msg) {\\n  var k = key.modulus.byteLength()\\n  var mLen = msg.length\\n  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()\\n  var hLen = iHash.length\\n  var hLen2 = 2 * hLen\\n  if (mLen > k - hLen2 - 2) {\\n    throw new Error('message too long')\\n  }\\n  var ps = Buffer.alloc(k - mLen - hLen2 - 2)\\n  var dblen = k - hLen - 1\\n  var seed = randomBytes(hLen)\\n  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))\\n  var maskedSeed = xor(seed, mgf(maskedDb, hLen))\\n  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))\\n}\\nfunction pkcs1 (key, msg, reverse) {\\n  var mLen = msg.length\\n  var k = key.modulus.byteLength()\\n  if (mLen > k - 11) {\\n    throw new Error('message too long')\\n  }\\n  var ps\\n  if (reverse) {\\n    ps = Buffer.alloc(k - mLen - 3, 0xff)\\n  } else {\\n    ps = nonZero(k - mLen - 3)\\n  }\\n  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))\\n}\\nfunction nonZero (len) {\\n  var out = Buffer.allocUnsafe(len)\\n  var i = 0\\n  var cache = randomBytes(len * 2)\\n  var cur = 0\\n  var num\\n  while (i < len) {\\n    if (cur === cache.length) {\\n      cache = randomBytes(len * 2)\\n      cur = 0\\n    }\\n    num = cache[cur++]\\n    if (num) {\\n      out[i++] = num\\n    }\\n  }\\n  return out\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parseKeys\",\"randomBytes\",\"createHash\",\"mgf\",\"xor\",\"BN\",\"withPublic\",\"crt\",\"Buffer\",\"module.exports\",\"publicKey\",\"msg\",\"reverse\",\"padding\",\"key\",\"k\",\"modulus\",\"byteLength\",\"mLen\",\"length\",\"iHash\",\"update\",\"alloc\",\"digest\",\"hLen\",\"hLen2\",\"Error\",\"ps\",\"dblen\",\"seed\",\"maskedDb\",\"concat\",\"maskedSeed\",\"out\",\"allocUnsafe\",\"len\",\"i\",\"cache\",\"cur\",\"num\",\"from\",\"paddedMsg\",\"cmp\"]\n}\n"]