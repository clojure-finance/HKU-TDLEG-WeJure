["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/multihashes/src/index.js"],"~:js","shadow$provide.module$node_modules$multihashes$src$index=function(global,require,module,exports){function validate(multihash){exports.decode(multihash)}const {Buffer}=require(\"module$node_modules$buffer$index\"),multibase=require(\"module$node_modules$multibase$src$index\"),varint=require(\"module$node_modules$varint$index\"),cs=require(\"module$node_modules$multihashes$src$constants\");exports.names=cs.names;exports.codes=cs.codes;exports.defaultLengths=cs.defaultLengths;exports.toHexString=function(hash){if(!Buffer.isBuffer(hash))throw Error(\"must be passed a buffer\");\nreturn hash.toString(\"hex\")};exports.fromHexString=function(hash){return Buffer.from(hash,\"hex\")};exports.toB58String=function(hash){if(!Buffer.isBuffer(hash))throw Error(\"must be passed a buffer\");return multibase.encode(\"base58btc\",hash).toString().slice(1)};exports.fromB58String=function(hash){let encoded=hash;Buffer.isBuffer(hash)&&(encoded=hash.toString());return multibase.decode(\"z\"+encoded)};exports.decode=function(buf){if(!Buffer.isBuffer(buf))throw Error(\"multihash must be a Buffer\");if(2>\nbuf.length)throw Error(\"multihash too short. must be \\x3e 2 bytes.\");const code=varint.decode(buf);if(!exports.isValidCode(code))throw Error(`multihash unknown function code: 0x${code.toString(16)}`);buf=buf.slice(varint.decode.bytes);const len=varint.decode(buf);if(0>len)throw Error(`multihash invalid length: ${len}`);buf=buf.slice(varint.decode.bytes);if(buf.length!==len)throw Error(`multihash length inconsistent: 0x${buf.toString(\"hex\")}`);return{code,name:cs.codes[code],length:len,digest:buf}};\nexports.encode=function(digest,code,length){if(!digest||void 0===code)throw Error(\"multihash encode requires at least two args: digest, code\");code=exports.coerceCode(code);if(!Buffer.isBuffer(digest))throw Error(\"digest should be a Buffer\");null==length&&(length=digest.length);if(length&&digest.length!==length)throw Error(\"digest length should be equal to specified length.\");return Buffer.concat([Buffer.from(varint.encode(code)),Buffer.from(varint.encode(length)),digest])};exports.coerceCode=function(name){let code=\nname;if(\"string\"===typeof name){if(void 0===cs.names[name])throw Error(`Unrecognized hash function named: ${name}`);code=cs.names[name]}if(\"number\"!==typeof code)throw Error(`Hash function code should be a number. Got: ${code}`);if(void 0===cs.codes[code]&&!exports.isAppCode(code))throw Error(`Unrecognized function code: ${code}`);return code};exports.isAppCode=function(code){return 0<code&&16>code};exports.isValidCode=function(code){return exports.isAppCode(code)||cs.codes[code]?!0:!1};exports.validate=\nvalidate;exports.prefix=function(multihash){validate(multihash);return multihash.slice(0,2)}}","~:source","shadow$provide[\"module$node_modules$multihashes$src$index\"] = function(global,require,module,exports) {\n/**\n * Multihash implementation in JavaScript.\n *\n * @module multihash\n */\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\nconst varint = require('varint')\nconst cs = require('./constants')\n\nexports.names = cs.names\nexports.codes = cs.codes\nexports.defaultLengths = cs.defaultLengths\n\n/**\n * Convert the given multihash to a hex encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toHexString = function toHexString (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return hash.toString('hex')\n}\n\n/**\n * Convert the given hex encoded string to a multihash.\n *\n * @param {string} hash\n * @returns {Buffer}\n */\nexports.fromHexString = function fromHexString (hash) {\n  return Buffer.from(hash, 'hex')\n}\n\n/**\n * Convert the given multihash to a base58 encoded string.\n *\n * @param {Buffer} hash\n * @returns {string}\n */\nexports.toB58String = function toB58String (hash) {\n  if (!Buffer.isBuffer(hash)) {\n    throw new Error('must be passed a buffer')\n  }\n\n  return multibase.encode('base58btc', hash).toString().slice(1)\n}\n\n/**\n * Convert the given base58 encoded string to a multihash.\n *\n * @param {string|Buffer} hash\n * @returns {Buffer}\n */\nexports.fromB58String = function fromB58String (hash) {\n  let encoded = hash\n  if (Buffer.isBuffer(hash)) {\n    encoded = hash.toString()\n  }\n\n  return multibase.decode('z' + encoded)\n}\n\n/**\n * Decode a hash from the given multihash.\n *\n * @param {Buffer} buf\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\n */\nexports.decode = function decode (buf) {\n  if (!(Buffer.isBuffer(buf))) {\n    throw new Error('multihash must be a Buffer')\n  }\n\n  if (buf.length < 2) {\n    throw new Error('multihash too short. must be > 2 bytes.')\n  }\n\n  const code = varint.decode(buf)\n  if (!exports.isValidCode(code)) {\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  const len = varint.decode(buf)\n  if (len < 0) {\n    throw new Error(`multihash invalid length: ${len}`)\n  }\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== len) {\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\n  }\n\n  return {\n    code: code,\n    name: cs.codes[code],\n    length: len,\n    digest: buf\n  }\n}\n\n/**\n *  Encode a hash digest along with the specified function code.\n *\n * > **Note:** the length is derived from the length of the digest itself.\n *\n * @param {Buffer} digest\n * @param {string|number} code\n * @param {number} [length]\n * @returns {Buffer}\n */\nexports.encode = function encode (digest, code, length) {\n  if (!digest || code === undefined) {\n    throw new Error('multihash encode requires at least two args: digest, code')\n  }\n\n  // ensure it's a hashfunction code.\n  const hashfn = exports.coerceCode(code)\n\n  if (!(Buffer.isBuffer(digest))) {\n    throw new Error('digest should be a Buffer')\n  }\n\n  if (length == null) {\n    length = digest.length\n  }\n\n  if (length && digest.length !== length) {\n    throw new Error('digest length should be equal to specified length.')\n  }\n\n  return Buffer.concat([\n    Buffer.from(varint.encode(hashfn)),\n    Buffer.from(varint.encode(length)),\n    digest\n  ])\n}\n\n/**\n * Converts a hash function name into the matching code.\n * If passed a number it will return the number if it's a valid code.\n * @param {string|number} name\n * @returns {number}\n */\nexports.coerceCode = function coerceCode (name) {\n  let code = name\n\n  if (typeof name === 'string') {\n    if (cs.names[name] === undefined) {\n      throw new Error(`Unrecognized hash function named: ${name}`)\n    }\n    code = cs.names[name]\n  }\n\n  if (typeof code !== 'number') {\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\n  }\n\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\n    throw new Error(`Unrecognized function code: ${code}`)\n  }\n\n  return code\n}\n\n/**\n * Checks wether a code is part of the app range\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isAppCode = function appCode (code) {\n  return code > 0 && code < 0x10\n}\n\n/**\n * Checks whether a multihash code is valid.\n *\n * @param {number} code\n * @returns {boolean}\n */\nexports.isValidCode = function validCode (code) {\n  if (exports.isAppCode(code)) {\n    return true\n  }\n\n  if (cs.codes[code]) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nfunction validate (multihash) {\n  exports.decode(multihash) // throws if bad.\n}\nexports.validate = validate\n\n/**\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\n *\n * @param {Buffer} multihash\n * @returns {undefined}\n * @throws {Error}\n */\nexports.prefix = function prefix (multihash) {\n  validate(multihash)\n\n  return multihash.slice(0, 2)\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$varint$index","~$module$node_modules$multihashes$src$constants","~$shadow.js","~$module$node_modules$multibase$src$index","~$module$node_modules$buffer$index"]],"~:properties",["^5",["toHexString","coerceCode","fromB58String","prefix","codes","validate","decode","isValidCode","toB58String","name","isAppCode","digest","length","names","fromHexString","defaultLengths","encode","code"]],"~:compiled-at",1644840880231,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$multihashes$src$index.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/multihashes/src/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$multihashes$src$index\\\"] = function(global,require,module,exports) {\\n/**\\n * Multihash implementation in JavaScript.\\n *\\n * @module multihash\\n */\\n'use strict'\\n\\nconst { Buffer } = require('buffer')\\nconst multibase = require('multibase')\\nconst varint = require('varint')\\nconst cs = require('./constants')\\n\\nexports.names = cs.names\\nexports.codes = cs.codes\\nexports.defaultLengths = cs.defaultLengths\\n\\n/**\\n * Convert the given multihash to a hex encoded string.\\n *\\n * @param {Buffer} hash\\n * @returns {string}\\n */\\nexports.toHexString = function toHexString (hash) {\\n  if (!Buffer.isBuffer(hash)) {\\n    throw new Error('must be passed a buffer')\\n  }\\n\\n  return hash.toString('hex')\\n}\\n\\n/**\\n * Convert the given hex encoded string to a multihash.\\n *\\n * @param {string} hash\\n * @returns {Buffer}\\n */\\nexports.fromHexString = function fromHexString (hash) {\\n  return Buffer.from(hash, 'hex')\\n}\\n\\n/**\\n * Convert the given multihash to a base58 encoded string.\\n *\\n * @param {Buffer} hash\\n * @returns {string}\\n */\\nexports.toB58String = function toB58String (hash) {\\n  if (!Buffer.isBuffer(hash)) {\\n    throw new Error('must be passed a buffer')\\n  }\\n\\n  return multibase.encode('base58btc', hash).toString().slice(1)\\n}\\n\\n/**\\n * Convert the given base58 encoded string to a multihash.\\n *\\n * @param {string|Buffer} hash\\n * @returns {Buffer}\\n */\\nexports.fromB58String = function fromB58String (hash) {\\n  let encoded = hash\\n  if (Buffer.isBuffer(hash)) {\\n    encoded = hash.toString()\\n  }\\n\\n  return multibase.decode('z' + encoded)\\n}\\n\\n/**\\n * Decode a hash from the given multihash.\\n *\\n * @param {Buffer} buf\\n * @returns {{code: number, name: string, length: number, digest: Buffer}} result\\n */\\nexports.decode = function decode (buf) {\\n  if (!(Buffer.isBuffer(buf))) {\\n    throw new Error('multihash must be a Buffer')\\n  }\\n\\n  if (buf.length < 2) {\\n    throw new Error('multihash too short. must be > 2 bytes.')\\n  }\\n\\n  const code = varint.decode(buf)\\n  if (!exports.isValidCode(code)) {\\n    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)\\n  }\\n  buf = buf.slice(varint.decode.bytes)\\n\\n  const len = varint.decode(buf)\\n  if (len < 0) {\\n    throw new Error(`multihash invalid length: ${len}`)\\n  }\\n  buf = buf.slice(varint.decode.bytes)\\n\\n  if (buf.length !== len) {\\n    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)\\n  }\\n\\n  return {\\n    code: code,\\n    name: cs.codes[code],\\n    length: len,\\n    digest: buf\\n  }\\n}\\n\\n/**\\n *  Encode a hash digest along with the specified function code.\\n *\\n * > **Note:** the length is derived from the length of the digest itself.\\n *\\n * @param {Buffer} digest\\n * @param {string|number} code\\n * @param {number} [length]\\n * @returns {Buffer}\\n */\\nexports.encode = function encode (digest, code, length) {\\n  if (!digest || code === undefined) {\\n    throw new Error('multihash encode requires at least two args: digest, code')\\n  }\\n\\n  // ensure it's a hashfunction code.\\n  const hashfn = exports.coerceCode(code)\\n\\n  if (!(Buffer.isBuffer(digest))) {\\n    throw new Error('digest should be a Buffer')\\n  }\\n\\n  if (length == null) {\\n    length = digest.length\\n  }\\n\\n  if (length && digest.length !== length) {\\n    throw new Error('digest length should be equal to specified length.')\\n  }\\n\\n  return Buffer.concat([\\n    Buffer.from(varint.encode(hashfn)),\\n    Buffer.from(varint.encode(length)),\\n    digest\\n  ])\\n}\\n\\n/**\\n * Converts a hash function name into the matching code.\\n * If passed a number it will return the number if it's a valid code.\\n * @param {string|number} name\\n * @returns {number}\\n */\\nexports.coerceCode = function coerceCode (name) {\\n  let code = name\\n\\n  if (typeof name === 'string') {\\n    if (cs.names[name] === undefined) {\\n      throw new Error(`Unrecognized hash function named: ${name}`)\\n    }\\n    code = cs.names[name]\\n  }\\n\\n  if (typeof code !== 'number') {\\n    throw new Error(`Hash function code should be a number. Got: ${code}`)\\n  }\\n\\n  if (cs.codes[code] === undefined && !exports.isAppCode(code)) {\\n    throw new Error(`Unrecognized function code: ${code}`)\\n  }\\n\\n  return code\\n}\\n\\n/**\\n * Checks wether a code is part of the app range\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nexports.isAppCode = function appCode (code) {\\n  return code > 0 && code < 0x10\\n}\\n\\n/**\\n * Checks whether a multihash code is valid.\\n *\\n * @param {number} code\\n * @returns {boolean}\\n */\\nexports.isValidCode = function validCode (code) {\\n  if (exports.isAppCode(code)) {\\n    return true\\n  }\\n\\n  if (cs.codes[code]) {\\n    return true\\n  }\\n\\n  return false\\n}\\n\\n/**\\n * Check if the given buffer is a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Buffer} multihash\\n * @returns {undefined}\\n * @throws {Error}\\n */\\nfunction validate (multihash) {\\n  exports.decode(multihash) // throws if bad.\\n}\\nexports.validate = validate\\n\\n/**\\n * Returns a prefix from a valid multihash. Throws an error if it is not valid.\\n *\\n * @param {Buffer} multihash\\n * @returns {undefined}\\n * @throws {Error}\\n */\\nexports.prefix = function prefix (multihash) {\\n  validate(multihash)\\n\\n  return multihash.slice(0, 2)\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"validate\",\"multihash\",\"decode\",\"Buffer\",\"multibase\",\"varint\",\"cs\",\"names\",\"codes\",\"defaultLengths\",\"toHexString\",\"exports.toHexString\",\"hash\",\"isBuffer\",\"Error\",\"toString\",\"fromHexString\",\"exports.fromHexString\",\"from\",\"toB58String\",\"exports.toB58String\",\"encode\",\"slice\",\"fromB58String\",\"exports.fromB58String\",\"encoded\",\"exports.decode\",\"buf\",\"length\",\"code\",\"isValidCode\",\"bytes\",\"len\",\"name\",\"digest\",\"exports.encode\",\"undefined\",\"hashfn\",\"coerceCode\",\"concat\",\"exports.coerceCode\",\"isAppCode\",\"exports.isAppCode\",\"exports.isValidCode\",\"prefix\",\"exports.prefix\"]\n}\n"]