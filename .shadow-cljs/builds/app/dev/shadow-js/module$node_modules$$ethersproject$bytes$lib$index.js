["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@ethersproject/bytes/lib/index.js"],"~:js","shadow$provide.module$node_modules$$ethersproject$bytes$lib$index=function(global,require,module,exports){function addSlice(array){if(array.slice)return array;array.slice=function(){var args=Array.prototype.slice.call(arguments);return addSlice(new Uint8Array(Array.prototype.slice.apply(array,args)))};return array}function isBytesLike(value){return isHexString(value)&&!(value.length%2)||isBytes(value)}function isInteger(value){return\"number\"===typeof value&&value==value&&0===value%1}function isBytes(value){if(null==\nvalue)return!1;if(value.constructor===Uint8Array)return!0;if(\"string\"===typeof value||!isInteger(value.length)||0>value.length)return!1;for(var i=0;i<value.length;i++){var v=value[i];if(!isInteger(v)||0>v||256<=v)return!1}return!0}function arrayify(value,options){options||(options={});if(\"number\"===typeof value){logger.checkSafeUint53(value,\"invalid arrayify value\");for(options=[];value;)options.unshift(value&255),value=parseInt(String(value/256));0===options.length&&options.push(0);return addSlice(new Uint8Array(options))}options.allowMissingPrefix&&\n\"string\"===typeof value&&\"0x\"!==value.substring(0,2)&&(value=\"0x\"+value);value.toHexString&&(value=value.toHexString());if(isHexString(value)){var hex=value.substring(2);hex.length%2&&(\"left\"===options.hexPad?hex=\"0x0\"+hex.substring(2):\"right\"===options.hexPad?hex+=\"0\":logger.throwArgumentError(\"hex data is odd-length\",\"value\",value));options=[];for(value=0;value<hex.length;value+=2)options.push(parseInt(hex.substring(value,value+2),16));return addSlice(new Uint8Array(options))}return isBytes(value)?\naddSlice(new Uint8Array(value)):logger.throwArgumentError(\"invalid arrayify value\",\"value\",value)}function concat(items){items=items.map(function(item){return arrayify(item)});var length=items.reduce(function(accum,item){return accum+item.length},0),result=new Uint8Array(length);items.reduce(function(offset,object){result.set(object,offset);return offset+object.length},0);return addSlice(result)}function zeroPad(value,length){value=arrayify(value);value.length>length&&logger.throwArgumentError(\"value out of range\",\n\"value\",value);var result=new Uint8Array(length);result.set(value,length-value.length);return addSlice(result)}function isHexString(value,length){return\"string\"!==typeof value||!value.match(/^0x[0-9A-Fa-f]*$/)||length&&value.length!==2+2*length?!1:!0}function hexlify(value,options){options||(options={});if(\"number\"===typeof value){logger.checkSafeUint53(value,\"invalid hexlify value\");for(options=\"\";value;)options=\"0123456789abcdef\"[value&15]+options,value=Math.floor(value/16);return options.length?\n(options.length%2&&(options=\"0\"+options),\"0x\"+options):\"0x00\"}if(\"bigint\"===typeof value)return value=value.toString(16),value.length%2?\"0x0\"+value:\"0x\"+value;options.allowMissingPrefix&&\"string\"===typeof value&&\"0x\"!==value.substring(0,2)&&(value=\"0x\"+value);if(value.toHexString)return value.toHexString();if(isHexString(value))return value.length%2&&(\"left\"===options.hexPad?value=\"0x0\"+value.substring(2):\"right\"===options.hexPad?value+=\"0\":logger.throwArgumentError(\"hex data is odd-length\",\"value\",\nvalue)),value.toLowerCase();if(isBytes(value)){options=\"0x\";for(var i=0;i<value.length;i++){var v=value[i];options+=\"0123456789abcdef\"[(v&240)>>4]+\"0123456789abcdef\"[v&15]}return options}return logger.throwArgumentError(\"invalid hexlify value\",\"value\",value)}function hexStripZeros(value){\"string\"!==typeof value&&(value=hexlify(value));isHexString(value)||logger.throwArgumentError(\"invalid hex string\",\"value\",value);value=value.substring(2);for(var offset=0;offset<value.length&&\"0\"===value[offset];)offset++;\nreturn\"0x\"+value.substring(offset)}function hexZeroPad(value,length){\"string\"!==typeof value?value=hexlify(value):isHexString(value)||logger.throwArgumentError(\"invalid hex string\",\"value\",value);for(value.length>2*length+2&&logger.throwArgumentError(\"value out of range\",\"value\",length);value.length<2*length+2;)value=\"0x0\"+value.substring(2);return value}function splitSignature(signature){var result={r:\"0x\",s:\"0x\",_vs:\"0x\",recoveryParam:0,v:0};if(isBytesLike(signature)){var bytes=arrayify(signature);\n65!==bytes.length&&logger.throwArgumentError(\"invalid signature string; must be 65 bytes\",\"signature\",signature);result.r=hexlify(bytes.slice(0,32));result.s=hexlify(bytes.slice(32,64));result.v=bytes[64];27>result.v&&(0===result.v||1===result.v?result.v+=27:logger.throwArgumentError(\"signature invalid v byte\",\"signature\",signature));result.recoveryParam=1-result.v%2;result.recoveryParam&&(bytes[32]|=128);result._vs=hexlify(bytes.slice(32,64))}else{result.r=signature.r;result.s=signature.s;result.v=\nsignature.v;result.recoveryParam=signature.recoveryParam;result._vs=signature._vs;if(null!=result._vs){bytes=zeroPad(arrayify(result._vs),32);result._vs=hexlify(bytes);var recoveryParam=128<=bytes[0]?1:0;null==result.recoveryParam?result.recoveryParam=recoveryParam:result.recoveryParam!==recoveryParam&&logger.throwArgumentError(\"signature recoveryParam mismatch _vs\",\"signature\",signature);bytes[0]&=127;bytes=hexlify(bytes);null==result.s?result.s=bytes:result.s!==bytes&&logger.throwArgumentError(\"signature v mismatch _vs\",\n\"signature\",signature)}null==result.recoveryParam?null==result.v?logger.throwArgumentError(\"signature missing v and recoveryParam\",\"signature\",signature):result.recoveryParam=0===result.v||1===result.v?result.v:1-result.v%2:null==result.v?result.v=27+result.recoveryParam:result.recoveryParam!==(0===result.v||1===result.v?result.v:1-result.v%2)&&logger.throwArgumentError(\"signature recoveryParam mismatch v\",\"signature\",signature);null!=result.r&&isHexString(result.r)?result.r=hexZeroPad(result.r,32):\nlogger.throwArgumentError(\"signature missing or invalid r\",\"signature\",signature);null!=result.s&&isHexString(result.s)?result.s=hexZeroPad(result.s,32):logger.throwArgumentError(\"signature missing or invalid s\",\"signature\",signature);bytes=arrayify(result.s);128<=bytes[0]&&logger.throwArgumentError(\"signature s out of range\",\"signature\",signature);result.recoveryParam&&(bytes[0]|=128);bytes=hexlify(bytes);result._vs&&(isHexString(result._vs)||logger.throwArgumentError(\"signature invalid _vs\",\"signature\",\nsignature),result._vs=hexZeroPad(result._vs,32));null==result._vs?result._vs=bytes:result._vs!==bytes&&logger.throwArgumentError(\"signature _vs mismatch v and s\",\"signature\",signature)}return result}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.joinSignature=exports.splitSignature=exports.hexZeroPad=exports.hexStripZeros=exports.hexValue=exports.hexConcat=exports.hexDataSlice=exports.hexDataLength=exports.hexlify=exports.isHexString=exports.zeroPad=exports.stripZeros=exports.concat=\nexports.arrayify=exports.isBytes=exports.isBytesLike=void 0;global=require(\"module$node_modules$$ethersproject$logger$lib$index\");require=require(\"module$node_modules$$ethersproject$bytes$lib$_version\");var logger=new global.Logger(require.version);exports.isBytesLike=isBytesLike;exports.isBytes=isBytes;exports.arrayify=arrayify;exports.concat=concat;exports.stripZeros=function(value){value=arrayify(value);if(0===value.length)return value;for(var start=0;start<value.length&&0===value[start];)start++;\nstart&&(value=value.slice(start));return value};exports.zeroPad=zeroPad;exports.isHexString=isHexString;exports.hexlify=hexlify;exports.hexDataLength=function(data){if(\"string\"!==typeof data)data=hexlify(data);else if(!isHexString(data)||data.length%2)return null;return(data.length-2)/2};exports.hexDataSlice=function(data,offset,endOffset){\"string\"!==typeof data?data=hexlify(data):(!isHexString(data)||data.length%2)&&logger.throwArgumentError(\"invalid hexData\",\"value\",data);offset=2+2*offset;return null!=\nendOffset?\"0x\"+data.substring(offset,2+2*endOffset):\"0x\"+data.substring(offset)};exports.hexConcat=function(items){var result=\"0x\";items.forEach(function(item){result+=hexlify(item).substring(2)});return result};exports.hexValue=function(value){value=hexStripZeros(hexlify(value,{hexPad:\"left\"}));return\"0x\"===value?\"0x0\":value};exports.hexStripZeros=hexStripZeros;exports.hexZeroPad=hexZeroPad;exports.splitSignature=splitSignature;exports.joinSignature=function(signature){signature=splitSignature(signature);\nreturn hexlify(concat([signature.r,signature.s,signature.recoveryParam?\"0x1c\":\"0x1b\"]))}}","~:source","shadow$provide[\"module$node_modules$$ethersproject$bytes$lib$index\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\nvar logger_1 = require(\"@ethersproject/logger\");\nvar _version_1 = require(\"./_version\");\nvar logger = new logger_1.Logger(_version_1.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        var args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nexports.isBytesLike = isBytesLike;\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (var i = 0; i < value.length; i++) {\n        var v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isBytes = isBytes;\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        var result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        var hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        var result = [];\n        for (var i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexports.arrayify = arrayify;\nfunction concat(items) {\n    var objects = items.map(function (item) { return arrayify(item); });\n    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n    var result = new Uint8Array(length);\n    objects.reduce(function (offset, object) {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nexports.concat = concat;\nfunction stripZeros(value) {\n    var result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    var start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexports.stripZeros = stripZeros;\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    var result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexports.zeroPad = zeroPad;\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\nvar HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        var hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        var result = \"0x\";\n        for (var i = 0; i < value.length; i++) {\n            var v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\nexports.hexlify = hexlify;\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexports.hexDataLength = hexDataLength;\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nexports.hexDataSlice = hexDataSlice;\nfunction hexConcat(items) {\n    var result = \"0x\";\n    items.forEach(function (item) {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nexports.hexConcat = hexConcat;\nfunction hexValue(value) {\n    var trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nexports.hexValue = hexValue;\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    var offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nexports.hexStripZeros = hexStripZeros;\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nexports.hexZeroPad = hexZeroPad;\nfunction splitSignature(signature) {\n    var result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0\n    };\n    if (isBytesLike(signature)) {\n        var bytes = arrayify(signature);\n        if (bytes.length !== 65) {\n            logger.throwArgumentError(\"invalid signature string; must be 65 bytes\", \"signature\", signature);\n        }\n        // Get the r, s and v\n        result.r = hexlify(bytes.slice(0, 32));\n        result.s = hexlify(bytes.slice(32, 64));\n        result.v = bytes[64];\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            var vs_1 = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs_1);\n            // Set or check the recid\n            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs_1[0] &= 0x7f;\n            var s = hexlify(vs_1);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        var vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        var _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    return result;\n}\nexports.splitSignature = splitSignature;\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\nexports.joinSignature = joinSignature;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$ethersproject$bytes$lib$_version","~$shadow.js","~$module$node_modules$$ethersproject$logger$lib$index"]],"~:properties",["^5",["zeroPad","isHexString","hexZeroPad","s","hexDataSlice","hexValue","recoveryParam","hexPad","isBytes","__esModule","hexDataLength","v","hexStripZeros","value","splitSignature","stripZeros","concat","joinSignature","r","arrayify","slice","hexlify","hexConcat","isBytesLike","_vs"]],"~:compiled-at",1644840880156,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$ethersproject$bytes$lib$index.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@ethersproject/bytes/lib/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$ethersproject$bytes$lib$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;\\nvar logger_1 = require(\\\"@ethersproject/logger\\\");\\nvar _version_1 = require(\\\"./_version\\\");\\nvar logger = new logger_1.Logger(_version_1.version);\\n///////////////////////////////\\nfunction isHexable(value) {\\n    return !!(value.toHexString);\\n}\\nfunction addSlice(array) {\\n    if (array.slice) {\\n        return array;\\n    }\\n    array.slice = function () {\\n        var args = Array.prototype.slice.call(arguments);\\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\\n    };\\n    return array;\\n}\\nfunction isBytesLike(value) {\\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\\n}\\nexports.isBytesLike = isBytesLike;\\nfunction isInteger(value) {\\n    return (typeof (value) === \\\"number\\\" && value == value && (value % 1) === 0);\\n}\\nfunction isBytes(value) {\\n    if (value == null) {\\n        return false;\\n    }\\n    if (value.constructor === Uint8Array) {\\n        return true;\\n    }\\n    if (typeof (value) === \\\"string\\\") {\\n        return false;\\n    }\\n    if (!isInteger(value.length) || value.length < 0) {\\n        return false;\\n    }\\n    for (var i = 0; i < value.length; i++) {\\n        var v = value[i];\\n        if (!isInteger(v) || v < 0 || v >= 256) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nexports.isBytes = isBytes;\\nfunction arrayify(value, options) {\\n    if (!options) {\\n        options = {};\\n    }\\n    if (typeof (value) === \\\"number\\\") {\\n        logger.checkSafeUint53(value, \\\"invalid arrayify value\\\");\\n        var result = [];\\n        while (value) {\\n            result.unshift(value & 0xff);\\n            value = parseInt(String(value / 256));\\n        }\\n        if (result.length === 0) {\\n            result.push(0);\\n        }\\n        return addSlice(new Uint8Array(result));\\n    }\\n    if (options.allowMissingPrefix && typeof (value) === \\\"string\\\" && value.substring(0, 2) !== \\\"0x\\\") {\\n        value = \\\"0x\\\" + value;\\n    }\\n    if (isHexable(value)) {\\n        value = value.toHexString();\\n    }\\n    if (isHexString(value)) {\\n        var hex = value.substring(2);\\n        if (hex.length % 2) {\\n            if (options.hexPad === \\\"left\\\") {\\n                hex = \\\"0x0\\\" + hex.substring(2);\\n            }\\n            else if (options.hexPad === \\\"right\\\") {\\n                hex += \\\"0\\\";\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"hex data is odd-length\\\", \\\"value\\\", value);\\n            }\\n        }\\n        var result = [];\\n        for (var i = 0; i < hex.length; i += 2) {\\n            result.push(parseInt(hex.substring(i, i + 2), 16));\\n        }\\n        return addSlice(new Uint8Array(result));\\n    }\\n    if (isBytes(value)) {\\n        return addSlice(new Uint8Array(value));\\n    }\\n    return logger.throwArgumentError(\\\"invalid arrayify value\\\", \\\"value\\\", value);\\n}\\nexports.arrayify = arrayify;\\nfunction concat(items) {\\n    var objects = items.map(function (item) { return arrayify(item); });\\n    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\\n    var result = new Uint8Array(length);\\n    objects.reduce(function (offset, object) {\\n        result.set(object, offset);\\n        return offset + object.length;\\n    }, 0);\\n    return addSlice(result);\\n}\\nexports.concat = concat;\\nfunction stripZeros(value) {\\n    var result = arrayify(value);\\n    if (result.length === 0) {\\n        return result;\\n    }\\n    // Find the first non-zero entry\\n    var start = 0;\\n    while (start < result.length && result[start] === 0) {\\n        start++;\\n    }\\n    // If we started with zeros, strip them\\n    if (start) {\\n        result = result.slice(start);\\n    }\\n    return result;\\n}\\nexports.stripZeros = stripZeros;\\nfunction zeroPad(value, length) {\\n    value = arrayify(value);\\n    if (value.length > length) {\\n        logger.throwArgumentError(\\\"value out of range\\\", \\\"value\\\", arguments[0]);\\n    }\\n    var result = new Uint8Array(length);\\n    result.set(value, length - value.length);\\n    return addSlice(result);\\n}\\nexports.zeroPad = zeroPad;\\nfunction isHexString(value, length) {\\n    if (typeof (value) !== \\\"string\\\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\\n        return false;\\n    }\\n    if (length && value.length !== 2 + 2 * length) {\\n        return false;\\n    }\\n    return true;\\n}\\nexports.isHexString = isHexString;\\nvar HexCharacters = \\\"0123456789abcdef\\\";\\nfunction hexlify(value, options) {\\n    if (!options) {\\n        options = {};\\n    }\\n    if (typeof (value) === \\\"number\\\") {\\n        logger.checkSafeUint53(value, \\\"invalid hexlify value\\\");\\n        var hex = \\\"\\\";\\n        while (value) {\\n            hex = HexCharacters[value & 0xf] + hex;\\n            value = Math.floor(value / 16);\\n        }\\n        if (hex.length) {\\n            if (hex.length % 2) {\\n                hex = \\\"0\\\" + hex;\\n            }\\n            return \\\"0x\\\" + hex;\\n        }\\n        return \\\"0x00\\\";\\n    }\\n    if (typeof (value) === \\\"bigint\\\") {\\n        value = value.toString(16);\\n        if (value.length % 2) {\\n            return (\\\"0x0\\\" + value);\\n        }\\n        return \\\"0x\\\" + value;\\n    }\\n    if (options.allowMissingPrefix && typeof (value) === \\\"string\\\" && value.substring(0, 2) !== \\\"0x\\\") {\\n        value = \\\"0x\\\" + value;\\n    }\\n    if (isHexable(value)) {\\n        return value.toHexString();\\n    }\\n    if (isHexString(value)) {\\n        if (value.length % 2) {\\n            if (options.hexPad === \\\"left\\\") {\\n                value = \\\"0x0\\\" + value.substring(2);\\n            }\\n            else if (options.hexPad === \\\"right\\\") {\\n                value += \\\"0\\\";\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"hex data is odd-length\\\", \\\"value\\\", value);\\n            }\\n        }\\n        return value.toLowerCase();\\n    }\\n    if (isBytes(value)) {\\n        var result = \\\"0x\\\";\\n        for (var i = 0; i < value.length; i++) {\\n            var v = value[i];\\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\\n        }\\n        return result;\\n    }\\n    return logger.throwArgumentError(\\\"invalid hexlify value\\\", \\\"value\\\", value);\\n}\\nexports.hexlify = hexlify;\\n/*\\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\\n    if (typeof(value) === \\\"string\\\" && value.length % 2 && value.substring(0, 2) === \\\"0x\\\") {\\n        return \\\"0x0\\\" + value.substring(2);\\n    }\\n    return value;\\n}\\n*/\\nfunction hexDataLength(data) {\\n    if (typeof (data) !== \\\"string\\\") {\\n        data = hexlify(data);\\n    }\\n    else if (!isHexString(data) || (data.length % 2)) {\\n        return null;\\n    }\\n    return (data.length - 2) / 2;\\n}\\nexports.hexDataLength = hexDataLength;\\nfunction hexDataSlice(data, offset, endOffset) {\\n    if (typeof (data) !== \\\"string\\\") {\\n        data = hexlify(data);\\n    }\\n    else if (!isHexString(data) || (data.length % 2)) {\\n        logger.throwArgumentError(\\\"invalid hexData\\\", \\\"value\\\", data);\\n    }\\n    offset = 2 + 2 * offset;\\n    if (endOffset != null) {\\n        return \\\"0x\\\" + data.substring(offset, 2 + 2 * endOffset);\\n    }\\n    return \\\"0x\\\" + data.substring(offset);\\n}\\nexports.hexDataSlice = hexDataSlice;\\nfunction hexConcat(items) {\\n    var result = \\\"0x\\\";\\n    items.forEach(function (item) {\\n        result += hexlify(item).substring(2);\\n    });\\n    return result;\\n}\\nexports.hexConcat = hexConcat;\\nfunction hexValue(value) {\\n    var trimmed = hexStripZeros(hexlify(value, { hexPad: \\\"left\\\" }));\\n    if (trimmed === \\\"0x\\\") {\\n        return \\\"0x0\\\";\\n    }\\n    return trimmed;\\n}\\nexports.hexValue = hexValue;\\nfunction hexStripZeros(value) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        value = hexlify(value);\\n    }\\n    if (!isHexString(value)) {\\n        logger.throwArgumentError(\\\"invalid hex string\\\", \\\"value\\\", value);\\n    }\\n    value = value.substring(2);\\n    var offset = 0;\\n    while (offset < value.length && value[offset] === \\\"0\\\") {\\n        offset++;\\n    }\\n    return \\\"0x\\\" + value.substring(offset);\\n}\\nexports.hexStripZeros = hexStripZeros;\\nfunction hexZeroPad(value, length) {\\n    if (typeof (value) !== \\\"string\\\") {\\n        value = hexlify(value);\\n    }\\n    else if (!isHexString(value)) {\\n        logger.throwArgumentError(\\\"invalid hex string\\\", \\\"value\\\", value);\\n    }\\n    if (value.length > 2 * length + 2) {\\n        logger.throwArgumentError(\\\"value out of range\\\", \\\"value\\\", arguments[1]);\\n    }\\n    while (value.length < 2 * length + 2) {\\n        value = \\\"0x0\\\" + value.substring(2);\\n    }\\n    return value;\\n}\\nexports.hexZeroPad = hexZeroPad;\\nfunction splitSignature(signature) {\\n    var result = {\\n        r: \\\"0x\\\",\\n        s: \\\"0x\\\",\\n        _vs: \\\"0x\\\",\\n        recoveryParam: 0,\\n        v: 0\\n    };\\n    if (isBytesLike(signature)) {\\n        var bytes = arrayify(signature);\\n        if (bytes.length !== 65) {\\n            logger.throwArgumentError(\\\"invalid signature string; must be 65 bytes\\\", \\\"signature\\\", signature);\\n        }\\n        // Get the r, s and v\\n        result.r = hexlify(bytes.slice(0, 32));\\n        result.s = hexlify(bytes.slice(32, 64));\\n        result.v = bytes[64];\\n        // Allow a recid to be used as the v\\n        if (result.v < 27) {\\n            if (result.v === 0 || result.v === 1) {\\n                result.v += 27;\\n            }\\n            else {\\n                logger.throwArgumentError(\\\"signature invalid v byte\\\", \\\"signature\\\", signature);\\n            }\\n        }\\n        // Compute recoveryParam from v\\n        result.recoveryParam = 1 - (result.v % 2);\\n        // Compute _vs from recoveryParam and s\\n        if (result.recoveryParam) {\\n            bytes[32] |= 0x80;\\n        }\\n        result._vs = hexlify(bytes.slice(32, 64));\\n    }\\n    else {\\n        result.r = signature.r;\\n        result.s = signature.s;\\n        result.v = signature.v;\\n        result.recoveryParam = signature.recoveryParam;\\n        result._vs = signature._vs;\\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\\n        // and verify non-missing s, v and recoveryParam\\n        if (result._vs != null) {\\n            var vs_1 = zeroPad(arrayify(result._vs), 32);\\n            result._vs = hexlify(vs_1);\\n            // Set or check the recid\\n            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\\n            if (result.recoveryParam == null) {\\n                result.recoveryParam = recoveryParam;\\n            }\\n            else if (result.recoveryParam !== recoveryParam) {\\n                logger.throwArgumentError(\\\"signature recoveryParam mismatch _vs\\\", \\\"signature\\\", signature);\\n            }\\n            // Set or check the s\\n            vs_1[0] &= 0x7f;\\n            var s = hexlify(vs_1);\\n            if (result.s == null) {\\n                result.s = s;\\n            }\\n            else if (result.s !== s) {\\n                logger.throwArgumentError(\\\"signature v mismatch _vs\\\", \\\"signature\\\", signature);\\n            }\\n        }\\n        // Use recid and v to populate each other\\n        if (result.recoveryParam == null) {\\n            if (result.v == null) {\\n                logger.throwArgumentError(\\\"signature missing v and recoveryParam\\\", \\\"signature\\\", signature);\\n            }\\n            else if (result.v === 0 || result.v === 1) {\\n                result.recoveryParam = result.v;\\n            }\\n            else {\\n                result.recoveryParam = 1 - (result.v % 2);\\n            }\\n        }\\n        else {\\n            if (result.v == null) {\\n                result.v = 27 + result.recoveryParam;\\n            }\\n            else {\\n                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\\n                if (result.recoveryParam !== recId) {\\n                    logger.throwArgumentError(\\\"signature recoveryParam mismatch v\\\", \\\"signature\\\", signature);\\n                }\\n            }\\n        }\\n        if (result.r == null || !isHexString(result.r)) {\\n            logger.throwArgumentError(\\\"signature missing or invalid r\\\", \\\"signature\\\", signature);\\n        }\\n        else {\\n            result.r = hexZeroPad(result.r, 32);\\n        }\\n        if (result.s == null || !isHexString(result.s)) {\\n            logger.throwArgumentError(\\\"signature missing or invalid s\\\", \\\"signature\\\", signature);\\n        }\\n        else {\\n            result.s = hexZeroPad(result.s, 32);\\n        }\\n        var vs = arrayify(result.s);\\n        if (vs[0] >= 128) {\\n            logger.throwArgumentError(\\\"signature s out of range\\\", \\\"signature\\\", signature);\\n        }\\n        if (result.recoveryParam) {\\n            vs[0] |= 0x80;\\n        }\\n        var _vs = hexlify(vs);\\n        if (result._vs) {\\n            if (!isHexString(result._vs)) {\\n                logger.throwArgumentError(\\\"signature invalid _vs\\\", \\\"signature\\\", signature);\\n            }\\n            result._vs = hexZeroPad(result._vs, 32);\\n        }\\n        // Set or check the _vs\\n        if (result._vs == null) {\\n            result._vs = _vs;\\n        }\\n        else if (result._vs !== _vs) {\\n            logger.throwArgumentError(\\\"signature _vs mismatch v and s\\\", \\\"signature\\\", signature);\\n        }\\n    }\\n    return result;\\n}\\nexports.splitSignature = splitSignature;\\nfunction joinSignature(signature) {\\n    signature = splitSignature(signature);\\n    return hexlify(concat([\\n        signature.r,\\n        signature.s,\\n        (signature.recoveryParam ? \\\"0x1c\\\" : \\\"0x1b\\\")\\n    ]));\\n}\\nexports.joinSignature = joinSignature;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"addSlice\",\"array\",\"slice\",\"array.slice\",\"args\",\"Array\",\"prototype\",\"call\",\"arguments\",\"Uint8Array\",\"apply\",\"isBytesLike\",\"value\",\"isHexString\",\"length\",\"isBytes\",\"isInteger\",\"constructor\",\"i\",\"v\",\"arrayify\",\"options\",\"logger\",\"checkSafeUint53\",\"result\",\"unshift\",\"parseInt\",\"String\",\"push\",\"allowMissingPrefix\",\"substring\",\"toHexString\",\"hex\",\"hexPad\",\"throwArgumentError\",\"concat\",\"items\",\"objects\",\"map\",\"item\",\"reduce\",\"accum\",\"offset\",\"object\",\"set\",\"zeroPad\",\"match\",\"hexlify\",\"HexCharacters\",\"Math\",\"floor\",\"toString\",\"toLowerCase\",\"hexStripZeros\",\"hexZeroPad\",\"splitSignature\",\"signature\",\"r\",\"s\",\"_vs\",\"recoveryParam\",\"bytes\",\"vs_1\",\"recId\",\"vs\",\"Object\",\"defineProperty\",\"joinSignature\",\"hexValue\",\"hexConcat\",\"hexDataSlice\",\"hexDataLength\",\"stripZeros\",\"logger_1\",\"_version_1\",\"Logger\",\"version\",\"start\",\"data\",\"endOffset\",\"forEach\",\"trimmed\"]\n}\n"]